/* main.c
   STM32G474VET6 â€” Example VCU tasks: ADC+DMA 500Hz, Control 1kHz, CAN handling
   Uses: HAL, FreeRTOS (cmsis_os_v2)
   Author: example for NYU Motorsports embedded+software interviews
*/

#include "stm32g4xx_hal.h"
#include "cmsis_os.h"
#include <string.h>
#include <stdint.h>
#include <stdbool.h>

/* ----------------- Configuration constants ----------------- */
#define ADC_BUF_LEN         16      // DMA circular buffer size (samples)
#define ADC_TIMER_HZ        500     // ADC sampling frequency (Hz)
#define CONTROL_HZ          1000    // Control task rate (Hz)
#define LOG_HZ              500     // Logging rate (Hz)
#define CAN_TX_MC_ID        0x100   // Example MC torque command ID (std)
#define BMS_VOLT_CURR_ID    0x201   // Example BMS message ID (std)
#define BMS_SOC_ID          0x202   // Another example BMS ID
#define BRAKE_FAULT_ID      0x010   // High-priority fault ID (low number)
#define CAN_STD             FDCAN_STANDARD_ID
#define MAX_CAN_RING        64      // Raw CAN ring buffer entries
#define TX_ROLLING_MAX      255

/* ----------------- Peripheral handles (extern from CubeMX) ----------------- */
FDCAN_HandleTypeDef hfdcan1;
ADC_HandleTypeDef  hadc1;
DMA_HandleTypeDef  hdma_adc1;
TIM_HandleTypeDef  htim3;   // used to trigger ADC at 500 Hz

/* ----------------- Shared data structures ----------------- */

// Raw CAN frame (what ISR pushes)
typedef struct {
    uint32_t id;
    uint8_t  dlc;
    uint8_t  data[8];
    uint32_t timestamp; // optional: HAL_GetTick()
} can_frame_t;

/* Ring buffer for raw CAN frames (ISR safe) */
typedef struct {
    can_frame_t buf[MAX_CAN_RING];
    volatile uint16_t head;
    volatile uint16_t tail;
} can_ring_t;

static can_ring_t can_rx_ring;

/* ADC DMA circular buffer (filled by DMA) */
static uint16_t adc_dma_buf[ADC_BUF_LEN]; // 12-bit ADC -> store in 16-bit

/* Latest unpacked signals (signal map) */
typedef struct {
    float pack_voltage;   // V
    float pack_current;   // A
    float soc;            // %
    uint16_t fault_flags; // bitfield from BMS
    volatile uint32_t last_update_ms;
} bms_signals_t;

static volatile bms_signals_t bms_signals;

/* Logging ring buffer for telemetry (simple) */
typedef struct {
    uint8_t buf[4096];
    volatile uint32_t wpos;
    volatile uint32_t rpos;
} log_ring_t;

static log_ring_t log_ring;

/* Control state */
static volatile bool control_fault = false;
static volatile uint8_t tx_rolling_counter = 0;

/* ----------------- Utility: ring buffer helpers ----------------- */
static inline bool can_ring_push(const can_frame_t *f) {
    uint16_t next = (can_rx_ring.head + 1) % MAX_CAN_RING;
    if (next == can_rx_ring.tail) return false; // full
    can_rx_ring.buf[can_rx_ring.head] = *f;
    __DSB(); // memory ordering
    can_rx_ring.head = next;
    return true;
}
static inline bool can_ring_pop(can_frame_t *out) {
    if (can_rx_ring.head == can_rx_ring.tail) return false; // empty
    *out = can_rx_ring.buf[can_rx_ring.tail];
    can_rx_ring.tail = (can_rx_ring.tail + 1) % MAX_CAN_RING;
    return true;
}

/* --------------- Peripheral initialization prototypes --------------- */
/* These are typically generated by CubeMX: MX_FDCAN1_Init, MX_ADC1_Init, MX_TIM3_Init, MX_DMA_Init.
   In your project, call those functions before starting scheduler. For brevity, not re-implemented here. */
extern void MX_FDCAN1_Init(void);
extern void MX_ADC1_Init(void);
extern void MX_TIM3_Init(void);
extern void MX_DMA_Init(void);

/* --------------- Forward declarations of tasks ----------------- */
void StartControlTask(void *argument);
void StartCanHandlerTask(void *argument);
void StartLoggingTask(void *argument);

/* --------------- CAN RX callback (HAL) -----------------
   Called in ISR context when new message arrives in FIFO0
   We read the message using HAL_FDCAN_GetRxMessage and push to ring.
   Note: CubeMX HAL wiring must route interrupt to HAL_FDCAN_IRQHandler and ActivateNotification.
*/
void HAL_FDCAN_RxFifo0Callback(FDCAN_HandleTypeDef *hfdcan, uint32_t RxFifo0ITs) {
    if ((RxFifo0ITs & FDCAN_IT_RX_FIFO0_NEW_MESSAGE) == 0) return;
    FDCAN_RxHeaderTypeDef rxHeader;
    uint8_t rxData[8];
    if (HAL_FDCAN_GetRxMessage(hfdcan, FDCAN_RX_FIFO0, &rxHeader, rxData) == HAL_OK) {
        can_frame_t f;
        f.id = rxHeader.Identifier;
        f.dlc = rxHeader.DataLength >> 16 ? 8 : rxHeader.DataLength; // simplified mapping
        memcpy(f.data, rxData, 8);
        f.timestamp = HAL_GetTick();
        // Push into ring (drop if full)
        can_ring_push(&f);
    }
}

/* --------------- ADC DMA conversion complete callback -----------------
   Optional: called when DMA buffer completely filled (or half filled if enabled).
   We do not wake the control task here. Logging task can use this if desired.
*/
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
    // Could set a flag for logger; keep minimal (no heavy work in ISR)
}

/* ----------------- CAN unpack helper: decode BMS frames ----------------- */
static void decode_bms_frame(const can_frame_t *f) {
    // Example: ID 0x201 => pack voltage (uint16, 0.1V/bit), current (int16, 0.1A/bit), SOC (uint8)
    if (f->id == BMS_VOLT_CURR_ID) {
        uint16_t raw_v = (uint16_t)(f->data[0] | (f->data[1] << 8));
        int16_t raw_i  = (int16_t)(f->data[2] | (f->data[3] << 8));
        uint8_t raw_soc = f->data[4];
        bms_signals.pack_voltage = raw_v * 0.1f;
        bms_signals.pack_current = raw_i * 0.1f;
        bms_signals.soc = (float)raw_soc;
        bms_signals.last_update_ms = HAL_GetTick();
    } else if (f->id == BMS_SOC_ID) {
        // Example second frame: fault flags
        bms_signals.fault_flags = (uint16_t)(f->data[0] | (f->data[1] << 8));
        bms_signals.last_update_ms = HAL_GetTick();
    }
}

/* ----------------- CAN transmit helper for MC_BRAKE_CMD ----------------- */
static HAL_StatusTypeDef send_mc_brake_cmd(int16_t brake_torque_01nm, uint8_t regen_pct, uint8_t pedal_pct, uint8_t flags) {
    // Pack to 6 bytes as previously defined
    uint8_t payload[6];
    payload[0] = (uint8_t)((brake_torque_01nm >> 8) & 0xFF);
    payload[1] = (uint8_t)(brake_torque_01nm & 0xFF);
    payload[2] = regen_pct;
    payload[3] = pedal_pct;
    payload[4] = flags;
    payload[5] = tx_rolling_counter++;
    FDCAN_TxHeaderTypeDef txHeader;
    txHeader.Identifier = CAN_TX_MC_ID;
    txHeader.IdType = FDCAN_STANDARD_ID;
    txHeader.TxFrameType = FDCAN_DATA_FRAME;
    txHeader.DataLength = FDCAN_DLC_BYTES_6;
    txHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
    txHeader.BitRateSwitch = FDCAN_BRS_OFF;
    txHeader.FDFormat = FDCAN_CLASSIC_CAN;
    txHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;
    txHeader.MessageMarker = 0;
    return HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &txHeader, payload);
}

/* ----------------- Control task (1 kHz) ----------------- */
void StartControlTask(void *argument) {
    TickType_t lastWake = xTaskGetTickCount();
    const TickType_t period = pdMS_TO_TICKS(1); // 1 ms
    // short filter buffer for pedal -> moving average of N samples
    const int filtN = 8;
    uint16_t local_samples[filtN];
    int filtIdx = 0;
    // calibration values (volts -> raw ADC units). set by calibration routine
    const uint16_t adc_min = 300;   // example raw ADC for 0% pedal
    const uint16_t adc_max = 3700;  // example raw ADC for 100% pedal

    for (;;) {
        vTaskDelayUntil(&lastWake, period);

        // Read latest ADC sample (DMA circular). Quick heuristic: pick most recent index.
        // If ADC is triggered at 500Hz, some control cycles will use the same latest sample twice.
        uint16_t latest;
        {
            // The DMA circle index: determine newest element by reading NDTR or index if available.
            // Simpler safe approach: read last element written by DMA: pick adc_dma_buf[(DMA_PTR + ADC_BUF_LEN - 1) % ADC_BUF_LEN]
            // For portability, just sample the array and pick the average of whole buffer's latest chunk:
            uint32_t sum = 0;
            for (int i = 0; i < ADC_BUF_LEN; ++i) sum += adc_dma_buf[i];
            latest = (uint16_t)(sum / ADC_BUF_LEN);
        }

        // moving average filter
        local_samples[filtIdx] = latest;
        filtIdx = (filtIdx + 1) % filtN;
        uint32_t sum = 0;
        for (int i = 0; i < filtN; ++i) sum += local_samples[i];
        uint16_t avg = (uint16_t)(sum / filtN);

        // Map ADC to percent (0-100)
        int pedal_pct = 0;
        if (avg <= adc_min) pedal_pct = 0;
        else if (avg >= adc_max) pedal_pct = 100;
        else pedal_pct = (int)( ( (int)avg - (int)adc_min ) * 100 / ( (int)adc_max - (int)adc_min ) );

        // Read BMS signals from signal map (atomic enough; if worried, protect with mutex)
        float pack_v = bms_signals.pack_voltage;
        float pack_i = bms_signals.pack_current;
        float soc    = bms_signals.soc;
        uint16_t bms_flags = bms_signals.fault_flags;

        // Plausibility checks
        if (bms_flags != 0) {
            control_fault = true;
        } else if (HAL_GetTick() - bms_signals.last_update_ms > 200) { // stale BMS >200ms
            control_fault = true;
        } else {
            control_fault = false;
        }

        // Compute torque request (simple mapping)
        // Let's request braking torque proportional to pedal: assume max braking torque 300 Nm
        int16_t torque_req_01nm = 0; // units: 0.01 Nm per bit
        if (!control_fault) {
            float torque_Nm = (pedal_pct / 100.0f) * 300.0f;
            torque_req_01nm = (int16_t)(torque_Nm * 100.0f); // convert to 0.01 Nm units
        } else {
            torque_req_01nm = 0; // safe
        }

        // Regen policy: limit regen by SOC and pack voltage/current
        uint8_t regen_pct = 0;
        if (!control_fault) {
            // naive policy: allow regen up to 80% if SOC < 90%, else 30%
            if (soc < 90.0f) regen_pct = 80;
            else regen_pct = 30;
            // further limit regen if pack current already near limit -> reduce (example)
            if (pack_i > 200.0f) regen_pct = regen_pct * 50 / 100;
        }

        // Flags: bit0 fault, bit1 limp mode placeholder
        uint8_t flags = control_fault ? 0x01 : 0x00;

        // Send CAN brake command (non-blocking)
        HAL_StatusTypeDef txs = send_mc_brake_cmd(torque_req_01nm, regen_pct, (uint8_t)pedal_pct, flags);
        if (txs != HAL_OK) {
            // if add-to-tx fails, set fault (optionally attempt resend)
            // keep minimal here
        }

        // Optional: produce a log entry (very small)
        // We write to RAM ring to avoid blocking
        uint8_t log_entry[12];
        uint32_t t = HAL_GetTick();
        memcpy(&log_entry[0], &t, 4);
        memcpy(&log_entry[4], &torque_req_01nm, 2);
        log_entry[6] = (uint8_t)pedal_pct;
        log_entry[7] = regen_pct;
        log_entry[8] = flags;
        // simple write - skip bounds checks for brevity
        uint32_t w = log_ring.wpos;
        if (w + sizeof(log_entry) < sizeof(log_ring.buf)) {
            memcpy(&log_ring.buf[w], log_entry, sizeof(log_entry));
            log_ring.wpos = w + sizeof(log_entry);
        } else {
            // simple wrap (overwrite oldest if needed)
            log_ring.wpos = 0;
        }
    }
}

/* ----------------- CAN handler task (unpacks raw frames -> signal map) -------------- */
void StartCanHandlerTask(void *argument) {
    can_frame_t f;
    for (;;) {
        // process any waiting frames; if none, sleep briefly
        while (can_ring_pop(&f)) {
            // decode known frames
            decode_bms_frame(&f);
            // (optionally) handle MC-to-VCU frames, faults, etc.
        }
        osDelay(1); // 1 ms idle
    }
}

/* ----------------- Logging task (writes RAM ring to SD/telemetry asynchronously) ----- */
void StartLoggingTask(void *argument) {
    for (;;) {
        // Example: flush small amount to UART/CAN3/SD - here we just simulate by consuming ring
        if (log_ring.rpos < log_ring.wpos) {
            // In real code: write to SD via FATFS or send via telemetry radio
            // For this sample, just advance read pointer to mark as consumed
            log_ring.rpos += 12; // if entries fixed 12 bytes
            if (log_ring.rpos >= log_ring.wpos) {
                // reset
                log_ring.rpos = 0;
                log_ring.wpos = 0;
            }
        }
        osDelay(pdMS_TO_TICKS(2)); // 500Hz-ish flush loop
    }
}

/* ----------------- main() ----------------- */
int main(void) {
    HAL_Init();
    SystemClock_Config(); // generated by CubeMX
    MX_DMA_Init();
    MX_ADC1_Init();
    MX_TIM3_Init();
    MX_FDCAN1_Init();

    // Start ADC in DMA circular mode - triggered by timer
    // Example HAL call: ADC configured in external TRGO so each timer tick triggers conversion
    HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adc_dma_buf, ADC_BUF_LEN);

    // Start timer that triggers ADC at 500Hz
    HAL_TIM_Base_Start(&htim3);

    // Start FDCAN: configure filters to accept BMS IDs
    HAL_FDCAN_Start(&hfdcan1);
    // configure notification for new RX messages in FIFO0
    HAL_FDCAN_ActivateNotification(&hfdcan1, FDCAN_IT_RX_FIFO0_NEW_MESSAGE, 0);

    // Create FreeRTOS tasks
    osKernelInitialize();
    osThreadNew(StartControlTask, NULL, &(osThreadAttr_t){ .name="Control", .priority = osPriorityRealtime, .stack_size=1024});
    osThreadNew(StartCanHandlerTask, NULL, &(osThreadAttr_t){ .name="CANH", .priority = osPriorityNormal, .stack_size=512});
    osThreadNew(StartLoggingTask, NULL, &(osThreadAttr_t){ .name="LOG", .priority = osPriorityLow, .stack_size=512});
    osKernelStart();

    // Should never reach here
    while (1) { }
}

/* --------------- Minimal fault handler (can be expanded) ---------------- */
void Error_Handler(void) {
    __disable_irq();
    while (1) { }
}

/* --------------- Notes about peripheral init (CubeMX) ----------------
 - ADC1: set external trigger source to TIM3 TRGO, resolution 12-bit, DMA circular, single conversion
 - TIM3: configured to produce update event at 500 Hz and TRGO on update
 - DMA: ADC1 -> memory, circular, half-word
 - FDCAN1: Nominal bit timing set for 1 Mbit/s (use CubeMX to compute prescaler, seg1/seg2, sjw)
   Configure standard ID filters to accept BMS and MC messages you care about.
 - NVIC: enable FDCAN1 interrupts and DMA interrupts as generated by CubeMX
 - FreeRTOS: CMSIS-RTOS v2 used (osThreadNew). Alternatively use xTaskCreate if using FreeRTOS native API.
*/

/* End of example */
